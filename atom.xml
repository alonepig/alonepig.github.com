<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Shjlone&#39;s Blog</title>
  
  <subtitle>Hello World</subtitle>
  <link href="http://shjlone.github.io/atom.xml" rel="self"/>
  
  <link href="http://shjlone.github.io/"/>
  <updated>2021-06-12T02:15:06.360Z</updated>
  <id>http://shjlone.github.io/</id>
  
  <author>
    <name>shjlone</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>多线程</title>
    <link href="http://shjlone.github.io/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://shjlone.github.io/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2021-06-12T02:15:06.360Z</published>
    <updated>2021-06-12T02:15:06.360Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程的概念"><a href="#线程的概念" class="headerlink" title="线程的概念"></a>线程的概念</h2><p>引入进程的目的，是为了使多道程序并发执行，以提高资源利用率和系统吞吐量；而引入线程，则是为了减小程序在并发执行时所付出的时空开销，<br>提高操作系统的并发性能。</p><p>线程最直接的理解就是“轻量级进程”，它是一个基本的CPU执行单元，也是程序执行流的最小单元，由线程ID、程序计数器、寄存器集合和堆栈组成。<br>线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点在运行中必不可少的资源，但它可与同属一个进程的其<br>他线程共享进程所拥有的全部资源。一个线程可以创建和撤销另一个线程，同一进程中的多个线程之间可以并发执行。由于线程之间的相互制约，致使线程在运<br>行中呈现出间断性。</p><h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><p><img src="./thread_1.png"></p><ul><li>新建状态:</li></ul><p>线程对象已经创建，还没有在其上调用start()方法。</p><ul><li>可运行状态:</li></ul><p>当线程有资格运行，但调度程序还没有把它选定为运行线程时线程所处的状态。当start()方法调用时，线程首先进入可运行状态。在线程运行之后或者从阻塞、等待或睡眠状态回来后，也返回到可运行状态。</p><ul><li>运行状态:</li></ul><p>就绪状态的线程获取了CPU，执行程序代码。</p><ul><li>阻塞状态:</li></ul><p>阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入可运行状态，才有机会转到运行状态。</p><p>阻塞的情况分三种：</p><pre><code>等待阻塞:运行的线程执行wait()方法，该线程会释放占用的所有资源，JVM会把该线程放入“等待池”中。进入这个状态后，是不能自动唤醒的，必须依靠其他线程调用notify()或notifyAll()方法才能被唤醒. (注意:当调用wait()后，线程会释放掉它所占有的&#39;锁&#39;，所以线程只有在持有&#39;锁&#39;才能进入可运行状态.)同步阻塞:运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入“锁池”中。其他阻塞:运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。</code></pre><ul><li>死亡状态:</li></ul><p>线程执行完了或者因异常退出了run()时就认为它死去。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦死亡，就不能复生。如果在一个死去的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。</p><h2 id="线程的实现方式"><a href="#线程的实现方式" class="headerlink" title="线程的实现方式"></a>线程的实现方式</h2><h2 id="线程间通讯"><a href="#线程间通讯" class="headerlink" title="线程间通讯"></a>线程间通讯</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;线程的概念&quot;&gt;&lt;a href=&quot;#线程的概念&quot; class=&quot;headerlink&quot; title=&quot;线程的概念&quot;&gt;&lt;/a&gt;线程的概念&lt;/h2&gt;&lt;p&gt;引入进程的目的，是为了使多道程序并发执行，以提高资源利用率和系统吞吐量；而引入线程，则是为了减小程序在并发执行时所付</summary>
      
    
    
    
    <category term="操作系统" scheme="http://shjlone.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="线程" scheme="http://shjlone.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="技术" scheme="http://shjlone.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="http://shjlone.github.io/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://shjlone.github.io/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-06-12T02:15:06.360Z</published>
    <updated>2021-06-12T02:15:06.360Z</updated>
    
    <content type="html"><![CDATA[<p>单例模式应该是最常见的设计模式了</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>定义：单例对象的类必须保证只有一个实例存在。</p><p>为了实现一个健壮的单例，我们应该思考需要做哪些事情？</p><ul><li>不能随意的让用户new出对象，所以构造函数应该是私有的</li><li>既然不能直接new，就应该有一个方法专门用来返回实例对象</li><li>不能clone</li><li>不能被反序列化</li><li>多线程使用时，如何保证线程安装</li></ul><h2 id="Java的实现方式"><a href="#Java的实现方式" class="headerlink" title="Java的实现方式"></a>Java的实现方式</h2><p>根据上面的思考，我们可以一步步的来实现单例模式。</p><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance; </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123; </span><br><span class="line">            instance = <span class="keyword">new</span> Singleton(); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> instance; </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用的时候才进行初始化，但此种写法是线程不安全的。那么是否把getInstance方法加一个锁就可以了呢？</p><h3 id="线程安全的懒汉式"><a href="#线程安全的懒汉式" class="headerlink" title="线程安全的懒汉式"></a>线程安全的懒汉式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance; </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123; </span><br><span class="line">            instance = <span class="keyword">new</span> Singleton(); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> instance; </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嗯，这种写法确实安全了，可是效率低，因为有更好的方式啊</p><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton(); </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> instance; &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>; </span><br><span class="line">    <span class="keyword">static</span> &#123; instance = <span class="keyword">new</span> Singleton(); &#125; </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> instance; &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>为什么叫饿汉呢？因为在类加载的时候对象就被创建了啊！这也是该方式不太好的地方，需要的实例应该要在需要用到的时候才初始化呢!<br>所以应该想想怎样才能延迟加载呢？</p><h3 id="静态内部类实现方式"><a href="#静态内部类实现方式" class="headerlink" title="静态内部类实现方式"></a>静态内部类实现方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123; </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton(); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE; </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SingletonHolder类没有被主动使用，只有显示通过调用getInstance方法时，才会显示装载SingletonHolder类，从而实例化instance。完美！！</p><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Singleton</span> </span>&#123; </span><br><span class="line">    INSTANCE; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whoAmI</span><span class="params">()</span> </span>&#123; System.out.println(<span class="keyword">this</span>.toString()); &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whoAmI</span><span class="params">()</span> </span>&#123; System.out.println(<span class="keyword">this</span>.toString()); &#125;   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">enum</span> <span class="title">SingletonEnum</span> </span>&#123;</span><br><span class="line">        SINGLETON;</span><br><span class="line">        <span class="keyword">private</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">SingletonEnum</span><span class="params">()</span></span>&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Java虚拟机会保证枚举类型不能被反射并且构造函数只被执行一次</strong></p><h3 id="双重检查锁模式"><a href="#双重检查锁模式" class="headerlink" title="双重检查锁模式"></a>双重检查锁模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>) </span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>为什么要这样写呢？</strong></p><p>其实这是懒汉式的升级版。懒汉式中所有线程在访问getInstance都会锁住，但实际情况中，很多时候只是读操作，<br>我们没有必要让每个线程都锁住才调用它。</p><p><strong>为什么要加volatile呢？</strong></p><p>因为JVM指令可重排，具体可以看看<a href="">volatile</a>这篇文档</p><h2 id="Kotlin的实现方式"><a href="#Kotlin的实现方式" class="headerlink" title="Kotlin的实现方式"></a>Kotlin的实现方式</h2><p>由于kotlin的语言特性，有些写法还是有别于Java的。</p><h3 id="饿汉式-1"><a href="#饿汉式-1" class="headerlink" title="饿汉式"></a>饿汉式</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> Singleton &#123;&#125;</span><br></pre></td></tr></table></figure><p>对！就是这么简单。以上代码转换成Java后，就是在静态代码块中初始化了Singleton。</p><h3 id="懒汉式-1"><a href="#懒汉式-1" class="headerlink" title="懒汉式"></a>懒汉式</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>() &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> instance: Singleton? = <span class="literal">null</span></span><br><span class="line">            <span class="keyword">get</span>() &#123;</span><br><span class="line">                <span class="keyword">if</span> (field == <span class="literal">null</span>) &#123;</span><br><span class="line">                    field = Singleton()</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> field</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">get</span><span class="params">()</span></span>: Singleton &#123;</span><br><span class="line">        <span class="comment">//这里不用getInstance作为为方法名，是因为在伴生对象声明时，内部已有getInstance方法，所以只能取其他名字</span></span><br><span class="line">         <span class="keyword">return</span> instance!!</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="线程安全的懒汉式-1"><a href="#线程安全的懒汉式-1" class="headerlink" title="线程安全的懒汉式"></a>线程安全的懒汉式</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> instance: Singleton? = <span class="literal">null</span></span><br><span class="line">            <span class="keyword">get</span>() &#123;</span><br><span class="line">                <span class="keyword">if</span> (field == <span class="literal">null</span>) field = Singleton()</span><br><span class="line">                <span class="keyword">return</span> field</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Synchronized</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">instance</span><span class="params">()</span></span>: Singleton &#123;</span><br><span class="line">            <span class="keyword">return</span> instance!!</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双重锁校验"><a href="#双重锁校验" class="headerlink" title="双重锁校验"></a>双重锁校验</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>() &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> instance <span class="keyword">by</span> lazy &#123; Singleton() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态内部类的实现"><a href="#静态内部类的实现" class="headerlink" title="静态内部类的实现"></a>静态内部类的实现</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>() &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@JvmStatic</span> <span class="comment">//方便Java中使用</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getInstance</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Holder.instance</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">object</span> Holder &#123;</span><br><span class="line">        <span class="keyword">val</span> instance = Singleton()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a></h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="如何处理反序列化"><a href="#如何处理反序列化" class="headerlink" title="如何处理反序列化"></a>如何处理反序列化</h2><p>最开始的分析指出，为了不让别人直接new，构造函数需要设置成私有的。除此之外，还可能被反序列化。那么怎么解决这个问题呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就行了？可以参考<a href="https://www.jianshu.com/p/ea1d9bc40341">https://www.jianshu.com/p/ea1d9bc40341</a>这篇文章了解原理。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在实际项目开发过程中，使用的最多还是双重锁校验和内部类的实现方式。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://zh.wikipedia.org/wiki/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F">https://zh.wikipedia.org/wiki/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F</a></li><li><a href="https://www.jianshu.com/p/ea1d9bc40341">https://www.jianshu.com/p/ea1d9bc40341</a></li><li><a href="https://blog.csdn.net/c10WTiybQ1Ye3/article/details/108806203">https://blog.csdn.net/c10WTiybQ1Ye3/article/details/108806203</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;单例模式应该是最常见的设计模式了&lt;/p&gt;
&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;定义：单例对象的类必须保证只有一个实例存在。&lt;/p&gt;
&lt;p&gt;为了实现一个健壮的单例，我们应该</summary>
      
    
    
    
    <category term="设计模式" scheme="http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="创建型模式" scheme="http://shjlone.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://shjlone.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Binder</title>
    <link href="http://shjlone.github.io/wiki/Android/%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/Binder/"/>
    <id>http://shjlone.github.io/wiki/Android/%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/Binder/</id>
    <published>2021-06-12T02:15:06.344Z</published>
    <updated>2021-06-12T02:15:06.344Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Android中IPC的不同方式比较"><a href="#Android中IPC的不同方式比较" class="headerlink" title="Android中IPC的不同方式比较"></a>Android中IPC的不同方式比较</h2><table><thead><tr><th>名称</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>Bundle</td><td>简单易用</td><td>只能传输Bundle支持的数据类型</td><td>四大组件间的进程间通信</td></tr><tr><td>文件共享</td><td>简单易用</td><td>不适合高并发场景，并且无法做到进程间的即时通信</td><td>无并发访问场景</td></tr><tr><td>AIDL</td><td>功能强大，支持一对多并发通信，支持实时通信</td><td>无</td><td>一对多通信且有RPC需求</td></tr><tr><td>Messager</td><td>功能一般，支持一对多并发通信，支持实时通信</td><td>不能很好处理高并发场景，不支持RPC</td><td>低并发的一对多通信，无RPC需求</td></tr><tr><td>ContentProvider</td><td>在数据源访问方面功能强大</td><td></td><td></td></tr><tr><td>Socket</td><td>功能强大</td><td></td><td></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Android中IPC的不同方式比较&quot;&gt;&lt;a href=&quot;#Android中IPC的不同方式比较&quot; class=&quot;headerlink&quot; title=&quot;Android中IPC的不同方式比较&quot;&gt;&lt;/a&gt;Android中IPC的不同方式比较&lt;/h2&gt;&lt;table&gt;
&lt;</summary>
      
    
    
    
    <category term="Android" scheme="http://shjlone.github.io/categories/Android/"/>
    
    <category term="进阶知识" scheme="http://shjlone.github.io/categories/Android/%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="Android" scheme="http://shjlone.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>ThreadPoolExecutor</title>
    <link href="http://shjlone.github.io/wiki/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/ThreadPoolExecutor/"/>
    <id>http://shjlone.github.io/wiki/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/ThreadPoolExecutor/</id>
    <published>2021-06-12T02:15:06.344Z</published>
    <updated>2021-06-12T02:15:06.344Z</updated>
    
    
    
    
    <category term="Java" scheme="http://shjlone.github.io/categories/Java/"/>
    
    <category term="并发编程" scheme="http://shjlone.github.io/categories/Java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Java" scheme="http://shjlone.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>RxJava</title>
    <link href="http://shjlone.github.io/wiki/Java/%E5%BC%80%E6%BA%90%E5%BA%93/RxJava/"/>
    <id>http://shjlone.github.io/wiki/Java/%E5%BC%80%E6%BA%90%E5%BA%93/RxJava/</id>
    <published>2021-06-12T02:15:06.344Z</published>
    <updated>2021-06-12T02:15:06.344Z</updated>
    
    
    
    
    <category term="Java" scheme="http://shjlone.github.io/categories/Java/"/>
    
    <category term="开源库" scheme="http://shjlone.github.io/categories/Java/%E5%BC%80%E6%BA%90%E5%BA%93/"/>
    
    
    <category term="Java" scheme="http://shjlone.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中的HashMap</title>
    <link href="http://shjlone.github.io/wiki/Java/%E9%9B%86%E5%90%88/HashMap/"/>
    <id>http://shjlone.github.io/wiki/Java/%E9%9B%86%E5%90%88/HashMap/</id>
    <published>2021-06-12T02:15:06.344Z</published>
    <updated>2021-06-12T02:15:06.344Z</updated>
    
    
    
    
    <category term="Java" scheme="http://shjlone.github.io/categories/Java/"/>
    
    <category term="集合" scheme="http://shjlone.github.io/categories/Java/%E9%9B%86%E5%90%88/"/>
    
    
    <category term="Java" scheme="http://shjlone.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>对于服务端开发的理解</title>
    <link href="http://shjlone.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9C%8D%E5%8A%A1%E7%AB%AF/%E5%AF%B9%E4%BA%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://shjlone.github.io/wiki/%E6%8A%80%E6%9C%AF%E5%BC%80%E5%8F%91/%E6%9C%8D%E5%8A%A1%E7%AB%AF/%E5%AF%B9%E4%BA%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91%E7%9A%84%E7%90%86%E8%A7%A3/</id>
    <published>2021-06-12T02:15:06.344Z</published>
    <updated>2021-06-12T02:15:06.344Z</updated>
    
    <content type="html"><![CDATA[<p>最近一段时间，开始了解并完成了一些后端需求。大致的过程如下：</p><ul><li>熟悉PHP，看了《PHP核心技术与最佳实践》、《PHP内核剖析》、《深入理解PHP内核》；</li><li>熟悉MySQL，看了《MySQL必知必会》，接下来会看《高性能MySQL》；</li><li>熟悉Redis，看了《Redis实战》；</li><li>阅读Symfony官网文档，了解其基本原理；</li><li>由于本地使用docker开发环境，所以对docker相关知识点也进行了一轮复习；</li></ul><p>整体来看，想使用PHP相关技术栈进行后端开发，经过上面的学习后，写写业务代码，一点问题都没有。公司使用PHP这一套技术栈，也是基于人力成本、开发效率各方面<br>因素综合考虑而定的。在现有体量下也确实是比较好的选择。因为自己本身有其他语言的底子在，学习的过程中还是蛮顺利的。现在回过头看看，后端的整体架构设计也是<br>根据体量的大小一步步进化来的。</p><p>当一个（小）项目刚开始时，使用Nginx+Symfony+MySQL，当业务量有所增长，这个时候需要加上缓存Redis；当业务继续增长，这个时候需要多台机器部署了，需要<br>使用负载均衡，Nginx进行反向代理，将流量分发到不同的机器；当业务继续增长，这个时候需要考虑部署多个数据库，进行主从同步；当业务继续增长，这个时候Redis也要<br>考虑使用集群。随着业务继续增长，数据库表的设计，如何分表。如何分库，业务代码如何写效率高，等等问题都要进行考虑了。当业务还在继续增长，可能有些事情用PHP来干<br>已经不是最优解了！</p><p>除了上面所说的一些技术选择外，为了保证服务器的稳定，还有很多事情要做的，比如要对服务器相关数据进行监控，比如请求数、慢请求数、服务器流量消耗情况等；要有<br>一套完善的日志系统；对数据库的监控；容灾机制等等。</p><p>这些知识的获取途径无外乎两种，一是业务增长喜人，给了你机会把这些坑都踩一遍；二是在大公司，现成的解决方案供你学习。所以，刚毕业的小菜鸟们，还是建议能去<br>大公司就尽量去大公司，做大做强的小公司太少了，不一定能被你撞上。</p><p><strong>服务端需要用到的技术或软件：</strong></p><ul><li>开发框架：Symfony、ThinkPHP等</li><li>消息队列：RabbitMQ等  </li><li>服务器：Nginx、Apache等</li><li>缓存：Redis、MemCached等</li><li>数据存储：MySQL、PostgreSQL等</li><li>代码部署：Walle等</li><li>数据监控：Zabbix等</li><li>日志分析系统：elk等</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近一段时间，开始了解并完成了一些后端需求。大致的过程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;熟悉PHP，看了《PHP核心技术与最佳实践》、《PHP内核剖析》、《深入理解PHP内核》；&lt;/li&gt;
&lt;li&gt;熟悉MySQL，看了《MySQL必知必会》，接下来会看《高性能MySQL》；</summary>
      
    
    
    
    <category term="随笔" scheme="http://shjlone.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>Glide</title>
    <link href="http://shjlone.github.io/wiki/Android/%E5%BC%80%E6%BA%90%E5%BA%93/Glide/"/>
    <id>http://shjlone.github.io/wiki/Android/%E5%BC%80%E6%BA%90%E5%BA%93/Glide/</id>
    <published>2021-06-12T02:15:06.329Z</published>
    <updated>2021-06-12T03:04:29.349Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>此篇文章只是用于记录使用Glide时要注意的点和一些使用技巧，如需查看基本使用，<br>请查阅<a href="http://bumptech.github.io/glide/">官方文档</a>。也可以看看<a href="../Glide%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/">Glide原理分析</a>。</p></blockquote><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><h3 id="缓存等级"><a href="#缓存等级" class="headerlink" title="缓存等级"></a><strong>缓存等级</strong></h3><ul><li>活动缓存：</li><li>内存缓存：</li><li>磁盘缓存：InternalCacheDiskCacheFactory（默认）</li></ul><h3 id="资源缓存方式"><a href="#资源缓存方式" class="headerlink" title="资源缓存方式"></a><strong>资源缓存方式</strong></h3><ul><li>DiskCacheStrategy.NONE 不缓存文件</li><li>DiskCacheStrategy.SOURCE 只缓存原图</li><li>DiskCacheStrategy.RESULT 只缓存最终加载的图（默认）</li><li>DiskCacheStrategy.ALL 同时缓存原图和结果图</li></ul><h3 id="缓存键"><a href="#缓存键" class="headerlink" title="缓存键"></a><strong>缓存键</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//缓存的键包括图片的宽、高、signature等参数</span></span><br><span class="line">EngineKey key = keyFactory.buildKey(model, signature, width, height, transformations,</span><br><span class="line">resourceClass, transcodeClass, options);</span><br></pre></td></tr></table></figure><p>默认策略配置</p><h2 id="重要知识点"><a href="#重要知识点" class="headerlink" title="重要知识点"></a>重要知识点</h2><ul><li>通过attach一个Fragment来监听Context的生命周期，合理的管理图片的加载和释放。</li><li>Glide默认采用的是RGB-565，相比ARGB-8888内存占用会减小一半。</li><li>会根据ImageView的尺寸来缓存图片，</li></ul><h2 id="常用配置"><a href="#常用配置" class="headerlink" title="常用配置"></a>常用配置</h2><h3 id="整合OkHttp3"><a href="#整合OkHttp3" class="headerlink" title="整合OkHttp3"></a>整合OkHttp3</h3><p>为了提升请求效率，使用更高效的OkHttp3来进行资源的下载。接入方式很简单，直接在gradle中引入</p><blockquote><p>compile “com.github.bumptech.glide:okhttp3-integration:4.11.0”</p></blockquote><p>它会自动添加以下配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GlideModule</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OkHttpLibraryGlideModule</span> <span class="keyword">extends</span> <span class="title">LibraryGlideModule</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerComponents</span><span class="params">(<span class="meta">@NonNull</span> Context context, <span class="meta">@NonNull</span> Glide glide,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="meta">@NonNull</span> Registry registry)</span> </span>&#123;</span><br><span class="line">    registry.replace(GlideUrl.class, InputStream.class, <span class="keyword">new</span> OkHttpUrlLoader.Factory());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://github.com/bumptech/glide">https://github.com/bumptech/glide</a></li><li><a href="http://bumptech.github.io/glide/">官方文档</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;此篇文章只是用于记录使用Glide时要注意的点和一些使用技巧，如需查看基本使用，&lt;br&gt;请查阅&lt;a href=&quot;http://bumptech.github.io/glide/&quot;&gt;官方文档&lt;/a&gt;。也可以看看&lt;a href=&quot;../Glide%E5</summary>
      
    
    
    
    <category term="Android" scheme="http://shjlone.github.io/categories/Android/"/>
    
    <category term="开源库" scheme="http://shjlone.github.io/categories/Android/%E5%BC%80%E6%BA%90%E5%BA%93/"/>
    
    
    <category term="Android" scheme="http://shjlone.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Glide原理分析</title>
    <link href="http://shjlone.github.io/wiki/Android/%E5%BC%80%E6%BA%90%E5%BA%93/Glide%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    <id>http://shjlone.github.io/wiki/Android/%E5%BC%80%E6%BA%90%E5%BA%93/Glide%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</id>
    <published>2021-06-12T02:15:06.329Z</published>
    <updated>2021-06-12T03:05:40.441Z</updated>
    
    <content type="html"><![CDATA[<h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href=""></a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;流程图&quot;&gt;&lt;a href=&quot;#流程图&quot; class=&quot;headerlink&quot; title=&quot;流程图&quot;&gt;&lt;/a&gt;流程图&lt;/h2&gt;&lt;h2 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h2&gt;&lt;u</summary>
      
    
    
    
    <category term="Android" scheme="http://shjlone.github.io/categories/Android/"/>
    
    <category term="开源库" scheme="http://shjlone.github.io/categories/Android/%E5%BC%80%E6%BA%90%E5%BA%93/"/>
    
    
    <category term="Android" scheme="http://shjlone.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>LeakCanary</title>
    <link href="http://shjlone.github.io/wiki/Android/%E5%BC%80%E6%BA%90%E5%BA%93/LeakCanary/"/>
    <id>http://shjlone.github.io/wiki/Android/%E5%BC%80%E6%BA%90%E5%BA%93/LeakCanary/</id>
    <published>2021-06-12T02:15:06.329Z</published>
    <updated>2021-06-12T02:15:06.329Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://square.github.io/leakcanary">https://square.github.io/leakcanary</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://square.github.io/leakcanary&quot;&gt;https://square.git</summary>
      
    
    
    
    <category term="Android" scheme="http://shjlone.github.io/categories/Android/"/>
    
    <category term="开源库" scheme="http://shjlone.github.io/categories/Android/%E5%BC%80%E6%BA%90%E5%BA%93/"/>
    
    
    <category term="Android" scheme="http://shjlone.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Bitmap造成的OOM的处理方式</title>
    <link href="http://shjlone.github.io/wiki/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/OOM%E4%B8%93%E9%A2%98/Bitmap%E9%80%A0%E6%88%90%E7%9A%84OOM%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/"/>
    <id>http://shjlone.github.io/wiki/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/OOM%E4%B8%93%E9%A2%98/Bitmap%E9%80%A0%E6%88%90%E7%9A%84OOM%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/</id>
    <published>2021-06-12T02:15:06.329Z</published>
    <updated>2021-06-12T02:15:06.329Z</updated>
    
    
    
    
    <category term="Android" scheme="http://shjlone.github.io/categories/Android/"/>
    
    <category term="性能优化" scheme="http://shjlone.github.io/categories/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    <category term="OOM专题" scheme="http://shjlone.github.io/categories/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/OOM%E4%B8%93%E9%A2%98/"/>
    
    
    <category term="Android" scheme="http://shjlone.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>内存溢出分析</title>
    <link href="http://shjlone.github.io/wiki/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/OOM%E4%B8%93%E9%A2%98/%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/"/>
    <id>http://shjlone.github.io/wiki/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/OOM%E4%B8%93%E9%A2%98/%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/</id>
    <published>2021-06-12T02:15:06.329Z</published>
    <updated>2021-06-12T02:15:06.329Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>OOM(Out of Memory)即内存溢出，是因为应用所需要分配的内存超过系统对应用内存的阈值，而抛出java.lang.OutOfMemoryError错误。</p><p>其根本原因是对象的生命周期不一致，导致内存泄漏。</p><h3 id="内存泄漏和内存溢出的区别"><a href="#内存泄漏和内存溢出的区别" class="headerlink" title="内存泄漏和内存溢出的区别"></a>内存泄漏和内存溢出的区别</h3><ul><li><p>内存溢出</p><p>  是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory。</p></li><li><p>内存泄漏</p><p>  是指程序在申请内存后，无法释放已申请的内存空间。内存泄漏最终会导致内存溢出。</p></li></ul><h3 id="栈内存溢出和堆内存溢出"><a href="#栈内存溢出和堆内存溢出" class="headerlink" title="栈内存溢出和堆内存溢出"></a>栈内存溢出和堆内存溢出</h3><h4 id="堆內存溢出"><a href="#堆內存溢出" class="headerlink" title="堆內存溢出"></a>堆內存溢出</h4><ul><li>抛出”StackOverflowError”的原因：线程请求的栈深度大于JVM所允许的最大深度。所以根本原因是，某个线程所需的栈内存超过了JVM的限制，<br>而此时物理内存仍有足够的可用空间。出现的情况：方法中无限递归调用。</li><li>抛出”OutOfMemoryError”的原因：无法（向操作系统）申请到足够的内存空间用来拓展栈。根本原因是，（操作系统管理的）物理内存已没有足够的<br>可用内存分配给JVM的栈使用。出现的情况：方法中不停的创建线程。</li></ul><h4 id="栈內存溢出"><a href="#栈內存溢出" class="headerlink" title="栈內存溢出"></a>栈內存溢出</h4><ul><li>new出来的对象所需内存不够了</li></ul><h2 id="可能出现OOM的场景"><a href="#可能出现OOM的场景" class="headerlink" title="可能出现OOM的场景"></a>可能出现OOM的场景</h2><h3 id="静态变量导致的内存泄漏"><a href="#静态变量导致的内存泄漏" class="headerlink" title="静态变量导致的内存泄漏"></a>静态变量导致的内存泄漏</h3><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>比如某个静态变量持有Activity，则当Activity生命周期结束时不会被释放</p><h4 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h4><p>在生命周期结束时释放静态变量</p><h3 id="单例模式导致的内存泄漏"><a href="#单例模式导致的内存泄漏" class="headerlink" title="单例模式导致的内存泄漏"></a>单例模式导致的内存泄漏</h3><h4 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h4><p>单例持有Activity</p><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><p>如果需要持有Context，则使用ApplicationContext</p><h3 id="属性动画导致的内存泄漏"><a href="#属性动画导致的内存泄漏" class="headerlink" title="属性动画导致的内存泄漏"></a>属性动画导致的内存泄漏</h3><h3 id="for循环中不停的创建局部变量"><a href="#for循环中不停的创建局部变量" class="headerlink" title="for循环中不停的创建局部变量"></a>for循环中不停的创建局部变量</h3><h3 id="非静态内部类（包括匿名内部类）默认会持有外部类的引用"><a href="#非静态内部类（包括匿名内部类）默认会持有外部类的引用" class="headerlink" title="非静态内部类（包括匿名内部类）默认会持有外部类的引用"></a>非静态内部类（包括匿名内部类）默认会持有外部类的引用</h3><p>当非静态内部类对象的生命周期，比外部类对象的生命周期长时，可能会导致内存泄漏。常出现于Handler、Thread、AsyncTask</p><p>解决方案：handler用static声明，使用软引用。</p><p><a href="http://cashow.github.io/Android-Anonymous-Inner-Class-Leaks-Memory.html">http://cashow.github.io/Android-Anonymous-Inner-Class-Leaks-Memory.html</a></p><h3 id="未取消注册或回调导致的内存泄漏"><a href="#未取消注册或回调导致的内存泄漏" class="headerlink" title="未取消注册或回调导致的内存泄漏"></a>未取消注册或回调导致的内存泄漏</h3><p>比如在Activity中注册广播，如果Activity销毁后不取消注册，那么这个广播就会一直存在系统中</p><h2 id="一些处理方式"><a href="#一些处理方式" class="headerlink" title="一些处理方式"></a>一些处理方式</h2><h3 id="在onDestroy中手动释放View上的资源，降低因为OOM而导致的内存消耗。"><a href="#在onDestroy中手动释放View上的资源，降低因为OOM而导致的内存消耗。" class="headerlink" title="在onDestroy中手动释放View上的资源，降低因为OOM而导致的内存消耗。"></a>在onDestroy中手动释放View上的资源，降低因为OOM而导致的内存消耗。</h3><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href=""></a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;OOM(Out of Memory)即内存溢出，是因为应用所需要分配的内存超过系统对应用内存的阈值，而抛出java.lang.OutOfMe</summary>
      
    
    
    
    <category term="Android" scheme="http://shjlone.github.io/categories/Android/"/>
    
    <category term="性能优化" scheme="http://shjlone.github.io/categories/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    <category term="OOM专题" scheme="http://shjlone.github.io/categories/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/OOM%E4%B8%93%E9%A2%98/"/>
    
    
    <category term="Android" scheme="http://shjlone.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>动画造成的OOM的处理方式</title>
    <link href="http://shjlone.github.io/wiki/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/OOM%E4%B8%93%E9%A2%98/%E5%8A%A8%E7%94%BB%E9%80%A0%E6%88%90%E7%9A%84OOM%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/"/>
    <id>http://shjlone.github.io/wiki/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/OOM%E4%B8%93%E9%A2%98/%E5%8A%A8%E7%94%BB%E9%80%A0%E6%88%90%E7%9A%84OOM%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/</id>
    <published>2021-06-12T02:15:06.329Z</published>
    <updated>2021-06-12T02:15:06.329Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h2&gt;</summary>
      
    
    
    
    <category term="Android" scheme="http://shjlone.github.io/categories/Android/"/>
    
    <category term="性能优化" scheme="http://shjlone.github.io/categories/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    <category term="OOM专题" scheme="http://shjlone.github.io/categories/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/OOM%E4%B8%93%E9%A2%98/"/>
    
    
    <category term="Android" scheme="http://shjlone.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>非静态内部类造成的OOM的处理方式</title>
    <link href="http://shjlone.github.io/wiki/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/OOM%E4%B8%93%E9%A2%98/%E9%9D%9E%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E9%80%A0%E6%88%90%E7%9A%84OOM%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/"/>
    <id>http://shjlone.github.io/wiki/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/OOM%E4%B8%93%E9%A2%98/%E9%9D%9E%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E9%80%A0%E6%88%90%E7%9A%84OOM%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F/</id>
    <published>2021-06-12T02:15:06.329Z</published>
    <updated>2021-06-12T02:15:06.329Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>我们日常写代码中，很容易写一些以下样子的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMInnerClassActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_oom_inner_class);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        EditText editText = findViewById(R.id.oom_edittext);</span><br><span class="line">        TextView textView = findViewById(R.id.oom_textview);</span><br><span class="line">        editText.addTextChangedListener(<span class="keyword">new</span> TextWatcher() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeTextChanged</span><span class="params">(CharSequence s, <span class="keyword">int</span> start, <span class="keyword">int</span> count, <span class="keyword">int</span> after)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTextChanged</span><span class="params">(CharSequence s, <span class="keyword">int</span> start, <span class="keyword">int</span> before, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">                textView.setText(s.toString());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterTextChanged</span><span class="params">(Editable s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，TextWatcher的匿名内部类是会持有Activity的引用的。如果它没有跟着Activity的生命周期一起销毁，则会引发内存泄漏。</p><p>为什么匿名内部类会持有外部引用而静态内部类不会呢？静态内部类它是静态的呀，只能访问外部的静态变量，无需持有外部对象的引用。</p><h2 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h2><p>其实这种现象跟Handler的处理方式是类似的，监听器持有弱引用，且生命周期结束时同步销毁。可参考以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OOMInnerClassRightActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> TextView textView;</span><br><span class="line">    EditText editText;</span><br><span class="line">    WeakTextWatcher weakTextWatcher;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_oom_inner_class);</span><br><span class="line"></span><br><span class="line">        editText = findViewById(R.id.oom_edittext);</span><br><span class="line">        textView = findViewById(R.id.oom_edittext);</span><br><span class="line"></span><br><span class="line">        weakTextWatcher = <span class="keyword">new</span> WeakTextWatcher(<span class="keyword">this</span>);</span><br><span class="line">        editText.addTextChangedListener(weakTextWatcher);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用静态内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakTextWatcher</span> <span class="keyword">implements</span> <span class="title">TextWatcher</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用弱引用</span></span><br><span class="line">        <span class="keyword">private</span> WeakReference&lt;OOMInnerClassRightActivity&gt; activityWeakReference;</span><br><span class="line"></span><br><span class="line">        WeakTextWatcher(OOMInnerClassRightActivity activity) &#123;</span><br><span class="line">            activityWeakReference = <span class="keyword">new</span> WeakReference&lt;OOMInnerClassRightActivity&gt;(activity);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeTextChanged</span><span class="params">(CharSequence s, <span class="keyword">int</span> start, <span class="keyword">int</span> count, <span class="keyword">int</span> after)</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTextChanged</span><span class="params">(CharSequence s, <span class="keyword">int</span> start, <span class="keyword">int</span> before, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">            OOMInnerClassRightActivity activity = activityWeakReference.get();</span><br><span class="line">            <span class="keyword">if</span>(activity != <span class="keyword">null</span>) &#123;</span><br><span class="line">                activity.textView.setText(s.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterTextChanged</span><span class="params">(Editable s)</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        <span class="comment">//释放监听</span></span><br><span class="line">        editText.removeTextChangedListener(weakTextWatcher);</span><br><span class="line">        weakTextWatcher = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以参考<a href="/wiki/Android/%E5%9F%BA%E7%A1%80/Handler%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/">Handler基本用法</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://cashow.github.io/Android-Anonymous-Inner-Class-Leaks-Memory.html">Android - 匿名内部类导致内存泄露的处理办法</a></li><li><a href="https://cloud.tencent.com/developer/article/1179625">匿名内部类导致内存泄露的面试题</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题分析&quot;&gt;&lt;a href=&quot;#问题分析&quot; class=&quot;headerlink&quot; title=&quot;问题分析&quot;&gt;&lt;/a&gt;问题分析&lt;/h2&gt;&lt;p&gt;我们日常写代码中，很容易写一些以下样子的代码：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;ta</summary>
      
    
    
    
    <category term="Android" scheme="http://shjlone.github.io/categories/Android/"/>
    
    <category term="性能优化" scheme="http://shjlone.github.io/categories/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    <category term="OOM专题" scheme="http://shjlone.github.io/categories/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/OOM%E4%B8%93%E9%A2%98/"/>
    
    
    <category term="Android" scheme="http://shjlone.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Handler基本用法</title>
    <link href="http://shjlone.github.io/wiki/Android/%E5%9F%BA%E7%A1%80/Handler%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"/>
    <id>http://shjlone.github.io/wiki/Android/%E5%9F%BA%E7%A1%80/Handler%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</id>
    <published>2021-06-12T02:15:06.322Z</published>
    <updated>2021-06-12T02:15:06.322Z</updated>
    
    <content type="html"><![CDATA[<p>Hanlder系列目录：</p><ul><li><a href="./Handler%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95.html">Handler基本用法</a></li><li><a href="./Handler%E5%8E%9F%E7%90%86.html">Handler原理</a></li></ul><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>A Handler allows you to send and process Message and Runnable objects associated with a thread’s MessageQueue. Each Handler instance<br>is associated with a single thread and that thread’s message queue. When you create a new Handler it is bound to a Looper.<br>It will deliver messages and runnables to that Looper’s message queue and execute them on that Looper’s thread.</p><p>There are two main uses for a Handler: (1) to schedule messages and runnables to be executed at some point in the future;<br>and (2) to enqueue an action to be performed on a different thread than your own.</p><p>Scheduling messages is accomplished with the post(Runnable), postAtTime(java.lang.Runnable, long),<br>postDelayed(Runnable, Object, long), sendEmptyMessage(int), sendMessage(Message), sendMessageAtTime(Message, long), and<br>sendMessageDelayed(Message, long) methods. The post versions allow you to enqueue Runnable objects to be called by the<br>message queue when they are received; the sendMessage versions allow you to enqueue a Message object containing a bundle<br>of data that will be processed by the Handler’s handleMessage(Message) method (requiring that you implement a subclass of Handler).</p><p>When posting or sending to a Handler, you can either allow the item to be processed as soon as the message queue is ready<br>to do so, or specify a delay before it gets processed or absolute time for it to be processed. The latter two allow you<br>to implement timeouts, ticks, and other timing-based behavior.</p><p>When a process is created for your application, its main thread is dedicated to running a message queue that takes care<br>of managing the top-level application objects (activities, broadcast receivers, etc) and any windows they create. You<br>can create your own threads, and communicate back with the main application thread through a Handler. This is done by<br>calling the same post or sendMessage methods as before, but from your new thread. The given Runnable or Message will then<br>be scheduled in the Handler’s message queue and processed when appropriate.</p><p>Handler用于Android中的线程通信。主要的用于在异步线程中发送<code>Message</code>或者直接运行一个<code>Runnable</code>，即可回到主线程执行UI操作。Handler在哪个线程<br>初始化，则它依附在哪个线程。Activity中有一个runOnUiThread方法，封装了Handler可以直接在异步线程中使用。Handler也可以延迟执行。</p><h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lqd.androidpractice.handler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Activity;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.os.Handler;</span><br><span class="line"><span class="keyword">import</span> android.os.Message;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.annotation.NonNull;</span><br><span class="line"><span class="keyword">import</span> androidx.annotation.Nullable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lqd.androidpractice.R;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.jetbrains.annotations.NotNull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.ref.WeakReference;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * handler 使用实例</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在异步线程发送消息到主线程刷新UI</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: a564</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2021/6/7</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String TAG = <span class="string">&quot;HandlerActivity&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TextView textView;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MyHandler myHandler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">        setContentView(R.layout.activity_handler);</span><br><span class="line"></span><br><span class="line">        textView = findViewById(R.id.ah_textview);</span><br><span class="line">        findViewById(R.id.ah_btn1).setOnClickListener(v -&gt; &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">super</span>.run();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    Log.d(TAG, Thread.currentThread().getStackTrace()[<span class="number">2</span>].getMethodName());</span><br><span class="line"></span><br><span class="line">                    Message msg = Message.obtain();</span><br><span class="line">                    msg.what = <span class="number">1</span>; <span class="comment">// 消息标识</span></span><br><span class="line">                    msg.obj = <span class="string">&quot;A&quot;</span>; <span class="comment">// 消息内存存放</span></span><br><span class="line">                    myHandler.sendMessage(msg); <span class="comment">// 异步线程发送消息</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//使用post</span></span><br><span class="line">                    myHandler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                            <span class="comment">//回到UI线程</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        myHandler = <span class="keyword">new</span> MyHandler(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        myHandler.removeCallbacksAndMessages(<span class="keyword">null</span>);<span class="comment">//跟随Activity销毁</span></span><br><span class="line">        myHandler = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        <span class="comment">//弱引用</span></span><br><span class="line">        WeakReference&lt;HandlerActivity&gt; activityWeakReference;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyHandler</span><span class="params">(HandlerActivity activity)</span> </span>&#123;</span><br><span class="line">            activityWeakReference = <span class="keyword">new</span> WeakReference&lt;HandlerActivity&gt;(activity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(<span class="meta">@NonNull</span> <span class="meta">@NotNull</span> Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line"></span><br><span class="line">            Log.d(TAG, Thread.currentThread().getStackTrace()[<span class="number">2</span>].getMethodName());</span><br><span class="line">            Log.d(TAG, msg.toString());</span><br><span class="line">            HandlerActivity activity = activityWeakReference.get();</span><br><span class="line">            <span class="keyword">if</span> (activity == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    activity.textView.setText(<span class="string">&quot;执行了线程1的UI操作&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    activity.textView.setText(<span class="string">&quot;执行了线程2的UI操作&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="HandlerThread"><a href="#HandlerThread" class="headerlink" title="HandlerThread"></a>HandlerThread</h2><p>顾名思义，HandlerThread使得Thread拥有的Handler的特性，可以在此线程中进行消息的分发和处理。使用场景也是创建异步线程并有数据交互。我们也可以<br>将其封装成一个工具类，这样不需要每次都new一个线程出来，方便使用且节省性能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BackgroundHandlerThread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> BackgroundHandlerThread _instance = <span class="keyword">new</span> BackgroundHandlerThread();</span><br><span class="line">        <span class="keyword">static</span>&#123;</span><br><span class="line">            _instance.init();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BackgroundHandlerThread <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Holder._instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HandlerThread mHandlerThread;</span><br><span class="line">    <span class="keyword">private</span> Handler mHandler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//HandlerThread的第二个参数为线程优先级</span></span><br><span class="line">        mHandlerThread = <span class="keyword">new</span> HandlerThread(BackgroundHandlerThread.class.getSimpleName());</span><br><span class="line">        mHandlerThread.start();</span><br><span class="line"></span><br><span class="line">        mHandler = <span class="keyword">new</span> Handler(mHandlerThread.getLooper())&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Looper <span class="title">getLooper</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mHandlerThread.getLooper();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Handler <span class="title">getHandler</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.mHandler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当需要异步执行的地方可以直接使用下面的代码</span></span><br><span class="line">BackgroundHandlerThread.getInstance().getHandler().post(Runnable)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="API介绍"><a href="#API介绍" class="headerlink" title="API介绍"></a>API介绍</h2><p><code>sendMessage(Message message)</code></p><p>发送消息到消息队列</p><p><code>post(Runnable runable)</code></p><p>把一个Runnable对象添加到消息队列中，这个方法会在对应Looper的线程中运行。</p><p><code>dispatchMessage(Message msg)</code></p><p>将消息分发给对应的Handler</p><p><code>handleMessage</code></p><p>根据某个消息类型进行处理</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://developer.android.com/reference/android/os/Handler">https://developer.android.com/reference/android/os/Handler</a></li><li><a href="https://droidyue.com/blog/2015/11/08/make-use-of-handlerthread/">详解 Android 中的 HandlerThread</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Hanlder系列目录：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;./Handler%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95.html&quot;&gt;Handler基本用法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;./Handler%E5%8E%</summary>
      
    
    
    
    <category term="Android" scheme="http://shjlone.github.io/categories/Android/"/>
    
    <category term="基础" scheme="http://shjlone.github.io/categories/Android/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Android" scheme="http://shjlone.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>ConstraintLayout</title>
    <link href="http://shjlone.github.io/wiki/Android/UI/ConstraintLayout/"/>
    <id>http://shjlone.github.io/wiki/Android/UI/ConstraintLayout/</id>
    <published>2021-06-12T02:15:06.306Z</published>
    <updated>2021-06-12T02:15:06.306Z</updated>
    
    <content type="html"><![CDATA[<h3 id="layout-constraintLeft-toRightOf的理解"><a href="#layout-constraintLeft-toRightOf的理解" class="headerlink" title="layout_constraintLeft_toRightOf的理解"></a>layout_constraintLeft_toRightOf的理解</h3><p>constraintXXX表示约束View自己，XXX分别表示上下左右等位置，toXXXOf表示约束依赖等对象，可以是同级的View，也可以是parent。</p><h3 id="layout-constraintBaseline-toBaselineOf"><a href="#layout-constraintBaseline-toBaselineOf" class="headerlink" title="layout_constraintBaseline_toBaselineOf"></a>layout_constraintBaseline_toBaselineOf</h3><p>对于TextView，可以使用基线对齐，这样文字就能对齐了。</p><h3 id="边距"><a href="#边距" class="headerlink" title="边距"></a>边距</h3><p><strong>不同方位的边距</strong></p><ul><li>android:layout_marginStart</li><li>android:layout_marginEnd</li><li>android:layout_marginLeft</li><li>android:layout_marginTop</li><li>android:layout_marginRight</li><li>android:layout_marginBottom</li></ul><p><strong>目标View隐藏时，以下属性生效</strong></p><ul><li>layout_goneMarginStart</li><li>layout_goneMarginEnd</li><li>layout_goneMarginLeft</li><li>layout_goneMarginTop</li><li>layout_goneMarginRight</li><li>layout_goneMarginBottom</li></ul><p>水平居中 layout_constraintLeft_toLeftOf &amp; layout_constraintRight_toRightOf<br>垂直居中 layout_constraintTop_toTopOf &amp; layout_constraintBottom_toBottomOf</p><p>layout_constraintHorizontal_bias 水平偏移<br>layout_constraintVertical_bias 垂直偏移</p><p>两个属性的取值范围在0-1。在水平偏移中，0表示最左，1表示最右；在垂直偏移，0表示最上，1表示最下；0.5表示中间。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;layout-constraintLeft-toRightOf的理解&quot;&gt;&lt;a href=&quot;#layout-constraintLeft-toRightOf的理解&quot; class=&quot;headerlink&quot; title=&quot;layout_constraintLeft_to</summary>
      
    
    
    
    <category term="Android" scheme="http://shjlone.github.io/categories/Android/"/>
    
    <category term="UI" scheme="http://shjlone.github.io/categories/Android/UI/"/>
    
    
    <category term="Android" scheme="http://shjlone.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Apk打包流程</title>
    <link href="http://shjlone.github.io/wiki/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/APK%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B/"/>
    <id>http://shjlone.github.io/wiki/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/APK%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B/</id>
    <published>2021-06-06T14:19:14.722Z</published>
    <updated>2021-06-06T14:19:48.576Z</updated>
    
    
    
    
    <category term="Android" scheme="http://shjlone.github.io/categories/Android/"/>
    
    <category term="性能优化" scheme="http://shjlone.github.io/categories/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="Android" scheme="http://shjlone.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>XML解析过程和原理</title>
    <link href="http://shjlone.github.io/wiki/Android/%E5%9F%BA%E7%A1%80/XML%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B%E5%92%8C%E5%8E%9F%E7%90%86/"/>
    <id>http://shjlone.github.io/wiki/Android/%E5%9F%BA%E7%A1%80/XML%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B%E5%92%8C%E5%8E%9F%E7%90%86/</id>
    <published>2021-06-06T14:17:04.341Z</published>
    <updated>2021-06-12T02:15:06.329Z</updated>
    
    
    
    
    <category term="Android" scheme="http://shjlone.github.io/categories/Android/"/>
    
    <category term="基础" scheme="http://shjlone.github.io/categories/Android/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Android" scheme="http://shjlone.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>View的基本概念</title>
    <link href="http://shjlone.github.io/wiki/Android/%E5%9F%BA%E7%A1%80/View%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>http://shjlone.github.io/wiki/Android/%E5%9F%BA%E7%A1%80/View%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</id>
    <published>2021-06-06T14:13:43.327Z</published>
    <updated>2021-06-06T14:14:00.393Z</updated>
    
    
    
    
    <category term="Android" scheme="http://shjlone.github.io/categories/Android/"/>
    
    <category term="基础" scheme="http://shjlone.github.io/categories/Android/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Android" scheme="http://shjlone.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>ContentProvider工作过程</title>
    <link href="http://shjlone.github.io/wiki/Android/%E5%9F%BA%E7%A1%80/ContentProvider%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B/"/>
    <id>http://shjlone.github.io/wiki/Android/%E5%9F%BA%E7%A1%80/ContentProvider%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B/</id>
    <published>2021-06-05T06:06:06.780Z</published>
    <updated>2021-06-12T02:15:06.322Z</updated>
    
    
    
    
    <category term="Android" scheme="http://shjlone.github.io/categories/Android/"/>
    
    <category term="基础" scheme="http://shjlone.github.io/categories/Android/%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Android" scheme="http://shjlone.github.io/tags/Android/"/>
    
  </entry>
  
</feed>
